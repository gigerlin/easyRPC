(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.Remote = require('./js/easyRpc').Remote;
exports.expose = require('./js/easyRpc').expose;

exports.server = require('./js/rpc');

exports.Promise = require('./js/promise');
exports.fetch = require('./js/fetch');

},{"./js/easyRpc":3,"./js/fetch":4,"./js/promise":6,"./js/rpc":8}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2016. All rights reserved.
 */

(function() {
  module.exports = {
    tag: 'rpc',
    sse: '_remoteReady',
    sessionTimeOut: 30 * 60 * 1000
  };

}).call(this);

},{}],3:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2016. All rights reserved.
 */

(function() {
  var EventSource, Promise, Remote, Response, cnf, fetch, http, log;

  log = require('./log');

  cnf = require('./config');

  exports.Remote = Remote = (function() {
    var send;

    function Remote(options) {
      var ctx, fn, i, len, method, ref;
      ctx = {
        count: 0,
        uid: Math.random().toString().substring(2, 10),
        request: (options.url || location.origin) + "/" + options["class"]
      };
      options.methods = options.methods || [];
      options.methods.push(cnf.sse);
      ref = options.methods;
      fn = (function(_this) {
        return function(method) {
          return _this[method] = function() {
            return send(ctx.request, {
              method: method,
              args: [].slice.call(arguments),
              id: ctx.uid + "-" + (++ctx.count)
            });
          };
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        method = ref[i];
        fn(method);
      }
    }

    send = function(request, msg) {
      log(msg.id + " out", msg);
      return new Promise(function(resolve, reject) {
        return fetch(request, {
          headers: {
            'Content-Type': 'application/json; charset=utf-8'
          },
          method: 'post',
          body: JSON.stringify(msg)
        })["catch"](function(err) {
          log(msg.id + " in: network error", err);
          return reject(err);
        }).then(function(response) {
          if (response.ok) {
            return response.json();
          } else {
            log(msg.id + " in: network error", response.statusText);
            return reject(response.statusText);
          }
        }).then(function(rep) {
          if (rep) {
            log(msg.id + " in", rep);
            if (rep.err) {
              return reject(rep.err);
            } else {
              return resolve(rep.rep);
            }
          }
        });
      });
    };

    return Remote;

  })();

  exports.expose = function(local, remote, url) {
    var method, methods, obj;
    local = local || {};
    methods = (function() {
      var results;
      results = [];
      for (method in local) {
        if (method.charAt(0) !== '_') {
          results.push(method);
        }
      }
      return results;
    })();
    remote = remote || (
      obj = {},
      obj["" + cnf.sse] = function() {
        return log("missing remote object in expose");
      },
      obj
    );
    return new Promise(function(resolve, reject) {
      var source;
      source = new EventSource(url ? url + "/" + cnf.tag : cnf.tag);
      return source.addEventListener(cnf.tag, function(e) {
        var msg;
        log('SSE in', e.data);
        msg = JSON.parse(e.data);
        if (msg.method) {
          if (local[msg.method]) {
            return local[msg.method].apply(local, msg.args);
          } else {
            return log('SSE error: no method', msg.method, 'for local object', local);
          }
        } else if (msg.uid) {
          remote[cnf.sse](msg.uid, methods);
          return resolve(source);
        }
      }, false);
    });
  };

  if (typeof window === 'object') {
    fetch = window.fetch || require('./fetch');
    Promise = window.Promise || require('./promise');
    EventSource = window.EventSource;
  } else if (typeof global === 'object') {
    Promise = global.Promise;
    http = require('http');
    EventSource = require('EventSource');
    fetch = function(uri, options) {
      return new Promise(function(resolve, reject) {
        var req, tmp;
        uri = uri.replace(/https?:\/\//, '');
        tmp = uri.split('/');
        options.path = "/" + tmp[1];
        tmp = tmp[0].split(':');
        options.hostname = tmp[0];
        if (tmp[1]) {
          options.port = tmp[1];
        }
        req = http.request(options, function(res) {
          res.setEncoding('utf8');
          return res.on('data', function(body) {
            if (body.indexOf('"') === -1) {
              return reject(body);
            } else {
              return resolve(new Response(body));
            }
          });
        });
        req.on('error', function(e) {
          return reject(e.message);
        });
        req.write(options.body);
        return req.end();
      });
    };
  }

  Response = (function() {
    function Response(data, ok) {
      this.data = data;
      this.ok = ok != null ? ok : true;
    }

    Response.prototype.json = function() {
      return JSON.parse(this.data);
    };

    return Response;

  })();

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./config":2,"./fetch":4,"./log":5,"./promise":6,"EventSource":undefined,"http":undefined}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2015. All rights reserved.
 */

(function() {
  var Promise, Response, fetch;

  if (typeof window === 'object') {
    Promise = window.Promise || require('./promise');
  }

  Response = (function() {
    function Response(data, ok) {
      this.data = data;
      this.ok = ok != null ? ok : true;
    }

    Response.prototype.json = function() {
      return JSON.parse(this.data);
    };

    return Response;

  })();

  module.exports = fetch = function(uri, options) {
    return new Promise(function(resolve, reject) {
      var xhr;
      xhr = new XMLHttpRequest();
      xhr.open(options.method, uri, true);
      xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');
      xhr.send(options.body || null);
      xhr.onload = function() {
        if (xhr.response.indexOf('"') === -1) {
          return reject(xhr.response);
        } else {
          return resolve(new Response(xhr.response));
        }
      };
      return xhr.onerror = function() {
        return reject("xhr error: " + xhr.statusText);
      };
    });
  };

}).call(this);

},{"./promise":6}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2016. All rights reserved.
 */

(function() {
  var slice = [].slice;

  module.exports = function() {
    var text;
    text = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, [new Date().toLocaleString(), '|'].concat(slice.call(text)));
  };

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2015. All rights reserved.
 */

(function() {
  var Promise,
    slice = [].slice;

  module.exports = Promise = (function() {
    Promise.prototype.status = 0;

    function Promise(ready) {
      this._chain = [];
      if (ready) {
        ready((function(_this) {
          return function() {
            return _this.resolve.apply(_this, arguments);
          };
        })(this), (function(_this) {
          return function() {
            return _this.reject.apply(_this, arguments);
          };
        })(this));
      }
    }

    Promise.prototype.then = function(resolve) {
      this._chain.push({
        type: 1,
        func: resolve
      });
      return this;
    };

    Promise.prototype["catch"] = function(reject) {
      this._chain.push({
        type: 2,
        func: reject
      });
      return this;
    };

    Promise.prototype.resolve = function() {
      return this._process.apply(this, [1].concat(slice.call(arguments)));
    };

    Promise.prototype.reject = function() {
      return this._process.apply(this, [2].concat(slice.call(arguments)));
    };

    Promise.prototype._process = function() {
      var args, error, evt, next, rst, type;
      type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (next = this._chain.shift()) {
        if (next.type === type) {
          try {
            if ((rst = next.func.apply(next, args)) instanceof Promise) {
              this.status = 0;
              return rst.then((function(_this) {
                return function(param) {
                  return _this.resolve(param);
                };
              })(this))["catch"]((function(_this) {
                return function(param) {
                  return _this.reject(param);
                };
              })(this));
            } else {
              this.status = type;
              return this.resolve(rst);
            }
          } catch (error) {
            evt = error;
            return this.reject(evt);
          }
        } else if (type === 1) {
          return this.resolve.apply(this, args);
        } else {
          return this.reject.apply(this, args);
        }
      }
    };

    return Promise;

  })();

}).call(this);

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Deux, Remote, Test, expose, rem2, remote, src,
    slice = [].slice;

  Remote = require('avs-easyrpc').Remote;

  expose = require('avs-easyrpc').expose;

  module.exports = remote = new Remote({
    "class": 'Employee',
    methods: ['getProfile', 'speak']
  });

  Test = (function() {
    function Test() {}

    Test.prototype.echo = function() {
      var text, user;
      user = arguments[0], text = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      console.log.apply(console, [user + ":"].concat(slice.call(text)));
      return $('#messages').append($('<li>').text(user + ":" + text[0]));
    };

    return Test;

  })();

  expose(new Test(), remote).then(function() {
    return remote.speak('hello');
  });

  remote.prespeak = function() {
    remote.speak($('#m').val());
    return $('#m').val('');
  };

  src = null;

  Deux = (function() {
    function Deux() {}

    Deux.prototype.test = function(msg) {
      console.log('deux: ', msg);
      return src.close();
    };

    return Deux;

  })();

  expose(new Deux(), new Remote({
    "class": 'Customer'
  })).then(function(source) {
    return src = source;
  });

  rem2 = new Remote({
    "class": 'doesnotexist',
    methods: ['test']
  });

  rem2.test().then(function(rep) {
    return console.log(rep);
  })["catch"](function(err) {
    return console.log(err);
  });


  /*
  remote.getProfile 'john'
  .then (rep) -> console.log rep
  .catch (err) -> console.log err
  
  remote.publish()
  .then (rep) -> console.log rep
  .catch (err) -> console.log err
   */

}).call(this);

},{"avs-easyrpc":1}],8:[function(require,module,exports){

},{}]},{},[7])(7)
});
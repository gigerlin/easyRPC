// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2015. All rights reserved.
 */

(function() {
  var Promise,
    slice = [].slice;

  module.exports = Promise = (function() {
    Promise.prototype.status = 0;

    function Promise(ready) {
      this._chain = [];
      if (ready) {
        ready((function(_this) {
          return function() {
            return _this.resolve.apply(_this, arguments);
          };
        })(this), (function(_this) {
          return function() {
            return _this.reject.apply(_this, arguments);
          };
        })(this));
      }
    }

    Promise.prototype.then = function(resolve) {
      this._chain.push({
        type: 1,
        func: resolve
      });
      return this;
    };

    Promise.prototype["catch"] = function(reject) {
      this._chain.push({
        type: 2,
        func: reject
      });
      return this;
    };

    Promise.prototype.resolve = function() {
      return this._process.apply(this, [1].concat(slice.call(arguments)));
    };

    Promise.prototype.reject = function() {
      return this._process.apply(this, [2].concat(slice.call(arguments)));
    };

    Promise.prototype._process = function() {
      var args, error, evt, next, rst, type;
      type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (next = this._chain.shift()) {
        if (next.type === type) {
          try {
            if ((rst = next.func.apply(next, args)) instanceof Promise) {
              this.status = 0;
              return rst.then((function(_this) {
                return function(param) {
                  return _this.resolve(param);
                };
              })(this))["catch"]((function(_this) {
                return function(param) {
                  return _this.reject(param);
                };
              })(this));
            } else {
              this.status = type;
              return this.resolve(rst);
            }
          } catch (error) {
            evt = error;
            return this.reject(evt);
          }
        } else if (type === 1) {
          return this.resolve.apply(this, args);
        } else {
          return this.reject.apply(this, args);
        }
      }
    };

    return Promise;

  })();

}).call(this);

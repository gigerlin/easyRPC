// Generated by CoffeeScript 1.10.0

/*
  @author Gilles Gerlinger
  Copyright 2016. All rights reserved.
 */

(function() {
  var EventSource, Promise, Remote, Response, Source, className, cnf, fetch, http, log, send;

  log = require('./log');

  cnf = require('./config');

  className = 'class name';

  exports.Remote = Remote = (function() {
    function Remote(options) {
      var count, ctx, fn, i, len, method, ref, uid;
      this[className] = options["class"];
      count = 0;
      uid = cnf.random();
      ctx = {
        use: options.use,
        request: (options.url || location.origin) + "/" + (encodeURIComponent(options["class"]))
      };
      options.methods = options.methods || [];
      options.methods.push(cnf.sse);
      ref = options.methods;
      fn = (function(_this) {
        return function(method) {
          return _this[method] = function() {
            return send(ctx, {
              method: method,
              args: [].slice.call(arguments),
              id: uid + "-" + (++count)
            });
          };
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        method = ref[i];
        fn(method);
      }
    }

    return Remote;

  })();

  send = function(ctx, msg) {
    log(msg.id + " out", msg);
    if (ctx.use) {
      msg.args = [ctx.use, msg.method].concat(msg.args);
      msg.method = 'invoke';
    }
    return new Promise(function(resolve, reject) {
      return fetch(ctx.request, {
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        },
        method: 'post',
        body: JSON.stringify(msg)
      })["catch"](function(err) {
        log(msg.id + " in", err);
        return reject(err);
      }).then(function(response) {
        if (response.ok) {
          return response.json();
        } else {
          log(msg.id + " in network error:", response.statusText);
          return reject(response.statusText);
        }
      }).then(function(rep) {
        if (rep) {
          log(msg.id + " in", rep);
          if (rep.err) {
            return reject(rep.err);
          } else {
            return resolve(rep.rep);
          }
        }
      });
    });
  };

  Source = (function() {
    function Source(source1, remoteID1) {
      this.source = source1;
      this.remoteID = remoteID1;
    }

    Source.prototype.close = function() {
      return this.source.close();
    };

    return Source;

  })();

  exports.expose = function(local, remote, url) {
    var method, methods, obj;
    if (url == null) {
      url = location.origin;
    }
    local = local || {};
    methods = (function() {
      var results;
      results = [];
      for (method in local) {
        if (method.charAt(0) !== '_') {
          results.push(method);
        }
      }
      return results;
    })();
    remote = remote || (
      obj = {},
      obj["" + cnf.sse] = function() {
        return log("missing remote object in expose");
      },
      obj
    );
    return new Promise(function(resolve, reject) {
      var source;
      source = new EventSource(url + "/" + cnf.tag);
      return source.addEventListener(cnf.tag, function(init) {
        var msg;
        log('SSE init', init.data);
        msg = JSON.parse(init.data);
        if (msg.uid) {
          source.uid = msg.uid;
          source.addEventListener(cnf.tag + "/" + msg.uid, function(e) {
            var rep;
            log('SSE in', e.type, e.data);
            msg = JSON.parse(e.data);
            if (msg.method) {
              if (local[msg.method]) {
                rep = local[msg.method].apply(local, msg.args);
                if (msg.args = rep) {
                  msg.method = cnf.srv;
                  return send({
                    request: url + "/" + (encodeURIComponent(remote[className]))
                  }, msg);
                }
              } else {
                return log('SSE error: no method', msg.method, 'for local object', local);
              }
            }
          });
          return remote[cnf.sse](msg.uid, methods).then(function(remoteID) {
            return resolve(new Source(source, remoteID));
          });
        }
      }, false);
    });
  };

  if (typeof window === 'object') {
    fetch = window.fetch || require('./fetch');
    Promise = window.Promise || require('./promise');
    EventSource = window.EventSource;
  } else if (typeof global === 'object') {
    Promise = global.Promise;
    http = require('http');
    EventSource = require('eventsource');
    fetch = function(uri, options) {
      return new Promise(function(resolve, reject) {
        var req, tmp;
        uri = uri.replace(/https?:\/\//, '');
        tmp = uri.split('/');
        options.path = "/" + tmp[1];
        tmp = tmp[0].split(':');
        options.hostname = tmp[0];
        if (tmp[1]) {
          options.port = tmp[1];
        }
        req = http.request(options, function(res) {
          res.setEncoding('utf8');
          return res.on('data', function(body) {
            if (body.indexOf('"') === -1) {
              return reject(body);
            } else {
              return resolve(new Response(body));
            }
          });
        });
        req.on('error', function(e) {
          return reject(e.message);
        });
        req.write(options.body);
        return req.end();
      });
    };
  }

  Response = (function() {
    function Response(data, ok) {
      this.data = data;
      this.ok = ok != null ? ok : true;
    }

    Response.prototype.json = function() {
      return JSON.parse(this.data);
    };

    return Response;

  })();

}).call(this);

// Generated by CoffeeScript 1.8.0

/*
  @author Gilles Gerlinger
  Copyright 2016. All rights reserved.
 */

(function() {
  var Rpc, classServer, expressRpc, log, parser, sessionTimeOut,
    __slice = [].slice;

  parser = require('body-parser');

  sessionTimeOut = 30 * 60 * 1000;

  Rpc = (function() {
    function Rpc(local) {
      this.local = local;
    }

    Rpc.prototype.process = function(msg) {
      log("" + msg.id + ": in", msg);
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var e, rep, _ref;
          if (_this.local[msg.method]) {
            try {
              rep = (_ref = _this.local)[msg.method].apply(_ref, msg.args);
              if (rep instanceof Promise) {
                rep.then(function(rep) {
                  return resolve(rep);
                });
                return rep["catch"](function(err) {
                  return reject(err);
                });
              } else {
                return resolve(rep);
              }
            } catch (_error) {
              e = _error;
              return reject("error in " + msg.method + ": " + e);
            }
          } else {
            return reject("error: method " + msg.method + " is unknown");
          }
        };
      })(this));
    };

    return Rpc;

  })();

  classServer = (function() {
    function classServer(classes, timeOut) {
      var Class, method;
      this.classes = classes;
      this.timeOut = timeOut != null ? timeOut : sessionTimeOut;
      this.methods = [];
      for (Class in this.classes) {
        this["" + Class + ".sessions"] = [];
        this.methods[Class] = (function() {
          var _results;
          _results = [];
          for (method in this.classes[Class].prototype) {
            if (method.charAt(0) !== '_' && method !== 'constructor') {
              _results.push(method);
            }
          }
          return _results;
        }).call(this);
      }
    }

    classServer.prototype.process = function(Class, msg) {
      var rpc, uid;
      uid = msg.id.split('-')[0];
      rpc = this["" + Class + ".sessions"][uid];
      this._resetTimeOut(Class, rpc, uid);
      if (!rpc) {
        log("adding new session " + Class + " " + uid + " (total: " + (Object.keys(this["" + Class + ".sessions"])) + ")");
        this["" + Class + ".sessions"][uid] = rpc = new Rpc(new this.classes[Class]());
        this._timeOut(Class, rpc, uid);
      }
      return new Promise(function(resolve, reject) {
        return rpc.process(msg).then(function(rep) {
          log("" + msg.id + ": out", rep);
          return resolve(rep);
        })["catch"](function(err) {
          return reject(err);
        });
      });
    };

    classServer.prototype._timeOut = function(Class, rpc, uid) {
      return rpc.timeOut = setTimeout((function(_this) {
        return function() {
          delete _this["" + Class + ".sessions"][uid];
          return log("removing session " + uid + " (total: " + (Object.keys(_this["" + Class + ".sessions"])) + ")");
        };
      })(this), this.timeOut);
    };

    classServer.prototype._resetTimeOut = function(Class, rpc, uid) {
      if (rpc) {
        clearTimeout(rpc.timeOut);
        return this._timeOut(Class, rpc, uid);
      }
    };

    return classServer;

  })();

  module.exports = expressRpc = (function() {
    function expressRpc(app, classes, options) {
      var Class, server;
      if (options == null) {
        options = {};
      }
      process.on('uncaughtException', function(err) {
        return log('Caught exception: ', err.stack);
      });
      app.use(parser.json({
        limit: options.limit || '512kb'
      }));
      app.use(function(err, req, res, next) {
        log(err.stack);
        return next(err);
      });
      server = new classServer(classes, options.timeOut);
      for (Class in classes) {
        app.post("/" + Class, function(req, res) {
          var err;
          try {
            return server.process(req.path.substring(1), req.body).then(function(rep) {
              return res.send({
                rep: rep
              });
            })["catch"](function(err) {
              return res.send({
                err: err
              });
            });
          } catch (_error) {
            err = _error;
            log(err.stack);
            return res.send({
              err: err
            });
          }
        });
      }
    }

    return expressRpc;

  })();

  log = function() {
    var text;
    text = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log.apply(console, [new Date().toISOString().replace('T', ' ').slice(0, 19), 'rpc'].concat(__slice.call(text)));
  };

}).call(this);
